<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
        <meta name="description" content="Probabilitic Models in Javascript : Restricted Boltzmann Machine">
        <meta name="author" content="m.zaradzki">

        <!-- Bootstrap core CSS -->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">

        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
        </script>
        <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <!--<p>
        When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$
        </p>-->
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.3.0/Chart.bundle.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.js"></script>
        <!--<script type="text/javascript" src="../gaussianvectors.js"></script>
        <script type="text/javascript" src="../winnertakeall.js"></script>
        <script type="text/javascript" src="../gmm.js"></script>
        <script type="text/javascript" src="../hmm.js"></script>-->
        <script type="text/javascript" src="../browserified/bundled.js"></script>
        <script>

            // Original files were compiled into batches for easy browser access by @karpathy.
            // See : http://cs.stanford.edu/people/karpathy/convnetjs/demo/mnist/
            // Load the dataset with JS in background
            var data_img_elts = [null, null, null, null, null, null];
            var img_data = [null, null, null, null, null];
            var loaded = [null, null, null, null, null];
            var load_data_batch = function(batch_num) {
                data_img_elts[batch_num] = new Image();
                var data_img_elt = data_img_elts[batch_num];
                data_img_elt.onload = function() { 
                    //var data_canvas = document.getElementById('datacanvas');
                    var data_canvas = document.createElement('canvas');
                    data_canvas.width = data_img_elt.width;
                    data_canvas.height = data_img_elt.height;
                    var data_ctx = data_canvas.getContext("2d");
                    data_ctx.drawImage(data_img_elt, 0, 0); // copy it over... bit wasteful :(
                    img_data[batch_num] = data_ctx.getImageData(0, 0, data_canvas.width, data_canvas.height);
                    // WARNING : the data array length is equal to 4*width*height
                    loaded[batch_num] = true;
                    /*if(batch_num < 20) {
                        loaded_train_batches.push(batch_num);
                    }*/
                    console.log('finished loading data batch ' + batch_num);
                };
                data_img_elt.src = "../mnist/mnist_batch_" + batch_num + ".png";
            };

            var mnistitem = function(batch_num, row) {
                // var batch_num = 1;
                var p = img_data[batch_num].data;
                //var row = 15; // any number from 0 to 2999, each row correspond to a digit image
                var W = 28*28;
                var vec = [];
                for(var i=0;i<W;i++) {
                  var ix = ((W * row) + i) * 4; // WARNING : the data array length is equal to 4*width*height
                  vec.push( p[ix]/255.0 ); // scale the data
                }
                return vec;
            };

            var vec_to_imageurl = function (vec28x28) {
                var G = [];
                for (var r=0; r<28; r++)
                {
                    var row = [];
                    for (var c=0; c<28; c++)
                    {
                        row.push( vec28x28[r*28+c] );
                    }
                    G.push(row);
                }
                var rgbs = numeric.mul([G,G,G], 254.9); // collate G 3x for RGB channels
                return numeric.imageURL(rgbs);
            };

            /*
            var data2 = [];
            for (var i=10; i<100; i++) {
                data2.push( mnistitem(1, i) );
            }
            var rbm2 = new dnn.RBM({
                input : data2,
                n_visible : 28*28,
                n_hidden : 20
            });
            rbm2.train({
                lr : 0.6,
                k : 1, // CD-k.
                epochs : trainingEpochs
            });

            // test by comparing an original image vs a reconstructed image
            var ovec = data2[10];
            var imgurlO = vec_to_imageurl( ovec );
            var rvec = rbm2.reconstruct([ovec,])[0];
            var imgurlR = vec_to_imageurl( rvec );
            //<img src="'+imgurlO+'" width=100 />
            //<img src="'+imgurlR+'" width=100 />
            */

            // int main
            $(window).load(function() {
                load_data_batch(1);
            });

            var data = [[1,1,1,0,0,0],
            [1,0,1,0,0,0],
            [1,1,1,0,0,0],
            [0,0,1,1,1,0],
            [0,0,1,1,0,0],
            [0,0,1,1,1,0]];
 
            var rbm = new dnn.RBM({
                input : data,
                n_visible : 6,
                n_hidden : 2
            });
            
            rbm.set('log level', 0); // 0 : nothing, 1 : info, 2 : warning.
             
            var trainingEpochs = 500;
             
            rbm.train({
                lr : 0.6,
                k : 1, // CD-k.
                epochs : trainingEpochs
            });

            //var v = [[1, 1, 0, 0, 0, 0],[0, 0, 0, 1, 1, 0]];
            //console.log(rbm.reconstruct(v));
            //console.log(rbm.sampleHgivenV(v)[0]); // get hidden layer probabilities from visible unit.
        </script>
    </head>
    <body>
        <div class="container">
        <div class="row"><div class="col-md-10 col-md-offset-1">
            <div class="row">
                <div class="page-header">
                    <h1>Restricted Boltzmann Machine (RBM)</h1>
                </div>
                <h4>Unsupervided learning with bi-partite (visible-hidden) graph</h4>
                <div id="log"></div>
            </div>
        </div></div>
        </div> <!-- /container -->
        <script>
            var v = [[1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0]];
            document.getElementById('log').innerHTML += 'visible unit: <br/>'
            document.getElementById('log').innerHTML += JSON.stringify(v) + '<br/>'
            document.getElementById('log').innerHTML += JSON.stringify(rbm.reconstruct(v)) + '<br/>'
            document.getElementById('log').innerHTML += 'get hidden layer probabilities from visible unit: <br/>'
            document.getElementById('log').innerHTML += JSON.stringify(rbm.sampleHgivenV(v)[0]) + '<br/>'
        </script>
    </body>
</html>